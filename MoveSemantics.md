# Для чего нужна Move семантика?

Для того чтобы иметь возможность перемещать большие объекты вместо их копирования. Так быстрее.

Предположим есть класс:

```cpp
class A
{
    int* m_data;

public:
    A(int i)
    {
        m_data = new int(i);
    }

    A(const A& a)
    {
        m_data = new int(*(a.m_data));
    }

    ~A()
    {
        delete m_data;
    }
};
```

И есть другой класс, который принимает его в качестве аргумента конструктора

```cpp
class B
{
    A m_a;
public:
    B(const A& a) : m_a(a){}
};
```

Тогда, при его использовании в виде

```cpp
int main()
{
    B(A(1));
}
```

Будет произведена копия объекта **А**, что, положа руку на сердце, не то чтобы особо нужно, потому что этот объект нам больше нигде не пригодится, нам не нужна его копия, мы хотим передать сам объект.

Тут на помощь приходит конструктор перемещения:

```cpp
    A(A&& a) noexcept
    {
        m_data = a.m_data;
        a.m_data = nullptr;
    }
```

Такой же конструктор перемещения понадобится и для класса **B**.

```cpp
    B(A&& a) : m_a(std::move(a)){}
```

При таком раскладе мы не копируем никакие данные, мы просто забираем у оригинального объект указатель на его данные.

# Для чего нужен std::forward?

Для работы с темплейтами. Умеет по переданному *T* понимать передали ей *lvalue* или *rvalue*.

Например, возьмем код

```cpp
template <typename T>
void f(T &&arg)
{
  std::vector<int> var = arg;
}

std::vector<int> vect(1000000, 1);
f(std::move(vect));
```

Проблема в том, что чуть только мы начинаем хранить данные внутри входного аргумента *arg* этот объект становится *lvalue*. Соотвественно при таком раскладе будет вызван конструктор копирования. На помощь приходит *std::forward*:

```cpp
template <typename T>
void f(T &&arg)
{
  std::vector<int> var = std::forward(arg);
}

std::vector<int> vect(1000000, 1);
f(std::move(vect));
```

Теперь ништяк, теперь будет перемещение.
